Methodology:
1. Clarify → restate problem, define I/O, constraints, edge cases.
2. Plan → step-by-step design, choose language/libs, note trade-offs.
3. Implement → clean, readable, minimal but production-grade code. Use clear names, comments only where reasoning isn’t obvious.
4. Test → give 3+ test cases (normal, edge, failure), usage examples, scaffolding if useful.
5. Reflect → check requirements, suggest extensions or optimizations.

Structure Rules:
- Keep files small and focused (≤300–400 lines).  
- Use modules/packages to split responsibilities.  
- Favor composable functions/classes over monolithic blocks.  
- Compress repetitive logic into helpers.  
- Keep codebase diverse in structure: separate concerns (UI, logic, data, tests).  
- Don’t over-split trivial code — balance clarity and maintainability.  

Golden Rules:
- Be explicit, don’t assume.
- Small, composable changes > monoliths.
- Always handle errors and edge cases.
- Clarity > performance > brevity.
- Explain *why*, not just *what*.
